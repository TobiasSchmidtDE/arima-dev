#-------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
#-------------------------------------------------------------

# Arguments
# 'X': X (one column time series - there has to be an .mtd file associated to the src file!)
# 'weights': (overwrites weights_src arg!) initialization string for weight matrix, see DML language documentation for matrix constructor using initialization string
# 'weights_src': path to weights file / arima model generated by arima training script
# 'p': p (non-seasonal AR order) (default 0)
# 'd': d (non-seasonal differencing order) (default 0)
# 'q': q (non-seasonal MA order) (default 0)
# 'solver': must be either 'forwardsub' for forward subsitution method or 'jacobi' for jacobi method or 'inverse' for directly calculating the inverse (default "jacobi")
# 'css_out': file name to store the condtional sum of squares (default "arima-css.csv")
# 'residuals_out': file name to store the residuals (default "arima-residuals.csv")
# 'result_format': the format of the destination file (default "csv")


arima_predict = function(Matrix[Double] weights, Matrix[Double] Z, Integer p, Integer q,  Integer ncond, String solver) return (Matrix[Double] x_hat){

	b = Z %*% weights

	A = diag(matrix(1, nrow(Z), 1)) #identity matrix

	if (q > 0){
    for(i in 1:q){
      A = addDiagonalToMatrix (A, as.scalar(theta[i]), nrow(A)-i)
    }
  }

	x_hat = eval(solver + "_solver", A, b)
}

arima_residuals = function(Matrix[Double] weights, Matrix[Double] X, Matrix[Double] Z, Integer p, Integer q,  Integer ncond, String solver) return (Matrix[Double] residuals){
	x_hat = arima_predict(weights, Z, p, q, ncond, solver)
  residuals = X - x_hat
	if (ncond > 0) residuals[1:ncond] = matrix (0, rows = ncond, cols = 1)
	residuals = replaceNaN(residuals, 0)
}

arima_sumofsquares = function(Matrix[Double] weights, Matrix[Double] X, Matrix[Double] Z, Integer p, Integer q,  Integer ncond, String solver) return (Double sumofsquares, Matrix[Double] residuals){
	residuals = arima_residuals(weights, X, Z, p, q, ncond, solver)
  sumofsquares = sum(residuals^2)/(nrow(X) - ncond)
}

arima_css = function(Matrix[Double] weights, Matrix[Double] X, Matrix[Double] Z, Integer p, Integer q,  Integer ncond, String solver) return (Double css, Matrix[Double] residuals){
	[sumofsquares,residuals] = arima_sumofsquares(weights, X, Z, p, q, ncond, solver)
	css = 0.5 * log (sumofsquares)
}

inverse_solver = function (Matrix[Double] A, Matrix[Double] b)  return (Matrix[Double] x){
	invA = L_triangular_inv(A);
	x = invA %*% b
}

# Inverse of lower triangular matrix
L_triangular_inv = function(Matrix[double] L) return(Matrix[double] A) {
  n = ncol(L)
  if (n == 1) {
    A = 1/L[1,1]
  }
  else if (n == 2) {
    A = matrix(0, 2, 2)
    A[1,1] = L[2,2]
    A[2,2] = L[1,1]
    A[2,1] = -L[2,1]
    A = A/(as.scalar(L[1,1] * L[2,2]))
  }
  else {
    k = as.integer(floor(n/2))

    L11 = L[1:k,1:k]
    L21 = L[k+1:n,1:k]
    L22 = L[k+1:n,k+1:n]

    A11 = L_triangular_inv(L11)
    A22 = L_triangular_inv(L22)
    A12 = matrix(0, nrow(A11), ncol(A22))
    A21 = -A22 %*% L21 %*% A11

    A = rbind(cbind(A11, A12), cbind(A21, A22))
  }
}

jacobi_solver = function (Matrix[Double] A, Matrix[Double] b)  return (Matrix[Double] x){
	tolerance = 1.0E-8
	max_iterations = 1000

	x = matrix(0, nrow(A), 1)
  iter = 0
 	diff = tolerance+1
 	diagVector_A = diag(A)
 	rest_A = A - diag(diagVector_A)

 	while(iter < max_iterations & diff > tolerance){
 		x_new =1/diagVector_A * (b - rest_A %*% x)
 		diff =sum(abs(x_new-x))
 		iter = iter + 1

		if (toString(diff) != "NaN") {
 			x = x_new
		}
 	}
}

forwardsub_solver = function (Matrix[Double] A, Matrix[Double] b)  return (Matrix[Double] x){
	x = matrix(0, nrow(A), 1)
  for (i in 1:nrow(A)){
		x[i,1] = (b[i,1] - A[i,] %*% x[,1]) / A[i,i]
  }
}

replaceNaN = function (Matrix[Double] M, Double replacement)return(Matrix[Double] M){
	hasNA = FALSE
	for (i in 1:nrow(M)){
		for (j in 1:ncol(M)){
			if (toString(as.scalar(M[i,j])) == "NaN"){
				M[i,j] = replacement
			}
		}
	}
}

addDiagonalToMatrix = function (Matrix[Double] M, Double diagValue, Integer diagSize)return (Matrix[Double] M){
	if (diagSize > 0){
		diagonal = diag(matrix(diagValue, diagSize, 1))
    startRow = nrow(M) - diagSize + 1
    endRow = nrow(M)
    startCol = 1
    endCol = diagSize
    M[startRow:endRow, startCol:endCol] = M[startRow:endRow, startCol:endCol] + diagonal
	}
}

#inserts the first column of source matrix into the n-th column of target matrix with the specified row offset
addShiftedMatrix = function (Matrix[Double] targetMatrix,  Matrix[Double] sourceMatrix, Integer rowOffset, Integer nthColumn)return (Matrix[Double] targetMatrix){
	if (rowOffset < nrow(targetMatrix)){
    targetMatrix[(rowOffset+1):nrow(targetMatrix), nthColumn] = sourceMatrix[1:(nrow(targetMatrix)-rowOffset)]
	}
}

constructPredictorMatrix = function(Matrix[Double] X, Integer p, Integer q,  Integer ncond) return (Matrix[Double] Z){
  totalColumns = p + q
	Z = matrix(0, rows = nrow(X), cols =totalColumns)

  # fills Z with values used for non seasonal AR prediction
  if (p > 0){
    for(i in 1:p){
      Z = addShiftedMatrix(Z, X, i, i)
    }
  }

  #prediction values for non seasonal MA
  if (q > 0){
    for(i in 1:q){
      Z = addShiftedMatrix(Z, X, i, p + i)
    }
  }

  if (ncond > 0){
    Z[1:ncond,] = matrix(0, rows = ncond, cols = totalColumns)
    if (q > 0){
      for (i in 1:q){
				ignoreRows = min(ncond+i, nrow(Z))
        Z[1:ignoreRows,(p+i)] = matrix(0, rows = ignoreRows, cols = 1)
      }
    }
	}
}


difference = function (Matrix[Double] X, Integer d) return (Matrix[Double] X){
	# d-th order non seasonal differencing:
	if (d > 0){
      for(i in 1:d){
  	    X[2:nrow(X)] = X[2:nrow(X)] - X[1:(nrow(X)-1)]
  	}
  }
}


X = read($X)

solver = ifdef($solver, "jacobi")
css_out = ifdef($css_out, "arima-css.csv")
residuals_out = ifdef($residuals_out, "arima-residuals.csv")
result_format = ifdef($result_format, "MM")
#n on-seasonal order
p =	ifdef($p, 0)
d = ifdef($d, 0)
q = ifdef($q, 0)

# The number of initial observations to ignore. It will be ignored if less than the maximum lag of an AR term. Also ignores
ncond = d + p

arima_string = "arima(p="+p+", d="+d+", q="+q+")"


# weights
weights_string = ifdef($weights, "")
weights_src = ifdef ($weights_src, "")

# number of weights that are expected
nweights = p+q
if (weights_string != ""){
	# TODO: check weights string contains exactly nweights.
	# Otherwise a weights_string with less then nweights entries will also work
	weights = matrix (weights_string, nweights, 1)
}
else if (weights_src != ""){
	weights = read(weights_src)
}
# check weights not empty:
else{
	print ("ERROR: IllegalArgument: No weights provided!")
	stop ("Stopped because of IllegalArgument")
}

# check at least one arima order p, q is not 0
if (nweights == 0){
	print ("ERROR: IllegalArgument: Calculating "+arima_string+" is not possible. At least one of the arguments p, q must be a non-zero!")
	stop ("Stopped because of IllegalArgument")
}

# check no arima order p, q is negative
if (p < 0 | d < 0 | q < 0){
	print ("ERROR: IllegalArgument: Calculating "+arima_string+" is not possible. There mustn't be any negative arguments!")
	stop ("Stopped because of IllegalArgument")
}

# check solver is jacobi|forwardsub|inverse
if (solver != "jacobi" & solver != "forwardsub" & solver != "inverse"){
	print ("ERROR: IllegalArgument: Solver must be either 'forwardsub' for forward subsitution method, 'jacobi' for jacobi method or 'inverse' for directly calculating the inverse.")
	stop ("Stopped because of IllegalArgument")
}

# check time series has sufficent amount of data.
if (ncond > nrow(X)){
	print ("ERROR: IllegalArgument: The time series X does not provide enough data points to calculate "+ arima_string+ ". At least "+ncond+" data points are needed!")
	stop ("Stopped because of IllegalArgument")
}

# check number of weights provided:
if (nrow(weights) != nweights | ncol(weights) != 1){
	print ("ERROR: IllegalArgument: Weights are of wrong dimension. Weights matrix dimension should be [" + nweights + ":1] but is [" + nrow(weights) + ":"+ ncol(weights) +"] instead. Check your weights file " + weights_src)
	stop ("Stopped because of IllegalArgument")
}


print ("")
print("nrow(X) = " + nrow(X))
print ("p = " + p)
print ("d = " + d)
print ("q = " + q)
print ("ncond = " + ncond)
print ("solver = " + solver)
print ("css_out = " + css_out)
print ("residuals_out = " + residuals_out)
print ("result_format = " + result_format)


diffX = difference(X, d)
Z = constructPredictorMatrix(diffX, p, q, ncond)
[css,residuals] = arima_css(weights, diffX, Z, p, q, ncond, solver)

print("arima_css = " + css)

write(css, css_out, format = result_format)
if (residuals_out!=""){
	write(residuals, residuals_out, format = result_format)
}
